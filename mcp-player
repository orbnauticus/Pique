#!/usr/bin/env python

DEBUG = True
TIME_FORMAT = 'hms'
def debug(*args):
	if DEBUG:
		print ' '.join(map(str,args))

import os
import select
import signal
import sys
import threading
import time

import pygtk, gtk, gobject
import pygst
pygst.require('0.10')
import gst

import library
import rawtty

Element = gst.element_factory_make
def Bin(*elements):
	#elements = [e if not isinstance(e,str) else Element(e) for e in elements]
	bin = gst.Bin()
	if len(elements):
		bin.add(*elements)
		if len(elements)-1:
			gst.element_link_many(*elements)
		for t,d,i in (('sinks',gst.PAD_SINK,0),('srcs',gst.PAD_SRC,-1)):
			j = 0
			for pad in elements[i].pads():
				if pad.props.direction == d:
					bin.add_pad(gst.GhostPad(t[:-1] + str(j), pad))
					j+=1
	return bin
	
class BgThread(threading.Thread):
	def __init__(self, *args, **kwargs):
		threading.Thread.__init__(self, target=self.main, args=args, kwargs=kwargs)
		self.daemon = True
		self.init()
		
	def init(self):
		pass
		
class IOThread(BgThread):
	def main(self):
		pass
	
class ConsoleThread(BgThread):
	def init(self):
		self.keymap = {}
		
	def connect(self, key, func, *args, **kwargs):
		self.keymap[key] = func,args,kwargs
	
	def main(self):
		for key in rawtty.keypresses(timeout=0.3):
			print key
			if key in self.keymap:
				f,args,kwargs = self.keymap[key]
				f(*args,**kwargs)
			else:
				debug('No Key Binding for', key)
		print 'done'
		
class PlayThread(BgThread):
	def main(self, gui):
		while True:
			gui.update()
			time.sleep(0.1)
			
def time_from_ns(ns):
	m,s = divmod(ns/gst.SECOND, 60)
	h,m = divmod(m,60)
	return '%d:%02d:%02d' % (h,m,s) if h else '%d:%02d' % (m,s)
	
class MediaButtons(gtk.VBox):
	def __init__(self):
		gtk.VBox.__init__(self)
		self.toolbar = gtk.Toolbar()
		self.toolbar.unset_flags(gtk.CAN_FOCUS)
		self.toolbar.set_orientation(gtk.ORIENTATION_HORIZONTAL)
		self.toolbar.set_show_arrow(False)
		
		self.widgets = {}
		for name,stock in (
			 ('previous',gtk.STOCK_MEDIA_PREVIOUS),
			 ('play-pause',gtk.STOCK_MEDIA_PLAY),
			 ('stop',gtk.STOCK_MEDIA_STOP),
			 ('next',gtk.STOCK_MEDIA_NEXT),):
			self.widgets[name] = gtk.ToolButton(stock)
			self.toolbar.insert(self.widgets[name], -1)
			self.widgets[name].get_child().unset_flags(gtk.CAN_FOCUS)
		
		self.position = gtk.Adjustment(step_incr=15*gst.SECOND,page_incr=60*gst.SECOND)
		self.slider = gtk.ToolItem()
		self.slider.set_expand(True)
		self.slider.add(gtk.HScale(self.position))
		self.slider.get_child().connect('format-value', self.format_time)
		self.slider.get_child().unset_flags(gtk.CAN_FOCUS)
		self.toolbar.insert(self.slider, -1)
		
		self.volume = gtk.ToolItem()
		self.volume.add(gtk.VolumeButton())
		self.volume.up = False
		self.volume.get_child().unset_flags(gtk.CAN_FOCUS)
		self.toolbar.insert(self.volume, -1)
		
		scale = self.volume.get_child().get_popup().get_child().get_child().get_children()[1]
		scale.connect('change-value', debug)
		
		self.widgets['fullscreen'] = gtk.ToggleToolButton(gtk.STOCK_FULLSCREEN)
		self.toolbar.insert(self.widgets['fullscreen'], -1)
		self.widgets['fullscreen'].get_child().unset_flags(gtk.CAN_FOCUS)
		
		self.pack_start(self.toolbar, expand=True, fill=True)
		
	def connect(self, which, func, *extra):
		if which in ('play-pause','stop','previous','next','fullscreen'):
			self.widgets[which].connect('clicked', func, *extra)
		elif which == 'position':
			self.slider.get_child().connect('change-value', func, *extra)
		elif which == 'volume':
			self.volume.get_child().get_popup().get_child().get_child().get_children()[1].connect('change-value', func, *extra)
		else:
			gtk.VBox.connect(self, which, func, *extra)
			
	def format_time(self, w, v):
		pos, dur = self.position.get_value(), self.position.get_upper()
		if TIME_FORMAT == 'percent':
			return "%2d%%" % (100 * pos / dur)
		elif TIME_FORMAT == 'hms':
			return ' / '.join([time_from_ns(x) for x in (pos,dur)])
		
	def set_duration(self, dur):
		self.position.set_upper(float(dur))
		
	def set_position(self, pos):
		self.position.set_value(pos)
		
	def set_volume(self, vol):
		self.volume.get_child().set_value(vol)
		
class KeyMap(object):
	def __init__(self, console, window):
		self.keys = {}
		self.console = console
		self.window = window
		self.window.connect('key-press-event', self.on_window_key_press_event)
		
	def add(self, key, func, *args, **kwargs):
		self.console.connect(key, func, *args, **kwargs)
		self.keys[key] = func,args,kwargs
		
	def on_window_key_press_event(self, widget, event):
		print widget, event

class Main(object):
	def __init__(self, files):
		self.lib = library.library(library.DEFAULT_PATH)
		
		def add_accel(gtkaccel, func, *args):
			key, mod = gtk.accelerator_parse(gtkaccel)
			debug(gtkaccel, key, mod, func.__name__, args)
			self.accelgroup.connect_group(key, mod, gtk.ACCEL_VISIBLE,
			  lambda g,w,k,m:(func(*args),))
		
		self.accelgroup = gtk.AccelGroup()
		add_accel('F11', self.toggle_fullscreen)
		add_accel('<Control>W', self.quit)
		
		vbox = gtk.VBox()
		
		self.console = ConsoleThread()
		self.keymap = KeyMap(self.console, vbox)
		self.keymap.add('f', self.toggle_fullscreen)
		self.keymap.add('n', self.next)
		self.keymap.add('space', self.play_pause)
		self.keymap.add('escape', self.stop)
		self.keymap.add('p', self.previous)
		self.keymap.add('c', self.toggle_controls)
		self.keymap.add('left', self.seek, -15*gst.SECOND, False, False)
		self.keymap.add('right', self.seek, 15*gst.SECOND, False, False)
		self.keymap.add('pgup', self.seek, 60*gst.SECOND, False, False)
		self.keymap.add('pgdn', self.seek, -60*gst.SECOND, False, False)
		self.keymap.add('up', self.set_volume, .05, False)
		self.keymap.add('down', self.set_volume, -.05, False)
		
		self.console.start()
		
		self.win = gtk.Window(gtk.WINDOW_TOPLEVEL)
		self.win.add_accel_group(self.accelgroup)
		self.win.set_title('Video-Player')
		self.win.set_default_size(500, 400)
		self.win.connect('destroy', self.on_destroy)
		self.win.__fullscreen = False
		self.win.connect('window-state-event', self.on_window_state_event)
		self.win.add(vbox)
		
		self.buttons = MediaButtons()
		self.buttons.connect('play-pause', lambda b:self.play_pause())
		self.buttons.connect('stop', lambda b:self.stop())
		self.buttons.connect('next', lambda b:self.next())
		self.buttons.connect('previous', lambda b:self.previous())
		self.buttons.connect('position', lambda a,t,v:self.seek(v, absolute=True, percent=False))
		self.buttons.connect('volume', lambda b,s,v:self.set_volume(v))
		self.buttons.connect('fullscreen', lambda b:self.fullscreen() if b.get_active() else self.unfullscreen())
		
		self.movie_window = gtk.DrawingArea()
		#self.movie_window.set_flags(gtk.CAN_FOCUS)
		self.movie_window.add_events(gtk.gdk.BUTTON_PRESS_MASK)
		vbox.add_events(gtk.gdk.KEY_PRESS_MASK)
		self.movie_window.connect('button-press-event', self.on_movie_window_clicked)
		vbox.connect('key-press-event', debug, 'key-press-event')
		self.movie_window.modify_bg(gtk.STATE_NORMAL, gtk.gdk.Color(0,0,0))
		vbox.pack_start(self.movie_window, True, True)
		vbox.pack_start(self.buttons, False, False)
		self.win.show_all()
		
		self.buttons.widgets['stop'].hide()

		self.player = gst.element_factory_make('playbin', 'player')

		self.taginject = Element('taginject')
		audio_bin = Bin(self.taginject, Element('rgvolume'), Element('gconfaudiosink'))
		self.player.set_property('audio-sink', audio_bin)
		
		video_sink = Element('xvimagesink')
		self.movie_window.connect('expose-event', self.on_expose_event, video_sink)
		video_sink.set_property('force-aspect-ratio', True)
		self.player.set_property('video-sink', video_sink)
		self.player.set_property('vis-plugin', Element('goom2k1'))
		
		self.playlist = iter(files)

		bus = self.player.get_bus()
		bus.add_signal_watch()
		bus.enable_sync_message_emission()
		bus.connect('message::eos', self.on_eos)
		bus.connect('message::error', self.on_error)
		bus.connect('message::state-changed', self.on_state_changed)
		
		IOThread().start()
		PlayThread(self).start()
		
		self.buttons.set_volume(0.8)
		self.load(self.playlist.next())
		self.play()
		
		signal.signal(signal.SIGINT, lambda s,f: self.quit())
		
	def seek(self, new, absolute=True, percent=False):
		format = gst.FORMAT_PERCENT if percent else gst.FORMAT_TIME
		if not absolute:
			new = max(0, new + self.get_position(percent=percent))
		debug('seek', format, new, absolute, percent)
		self.player.seek_simple(format, gst.SEEK_FLAG_FLUSH, new)
			 
	def isplaying(self):
		return self.player.get_state()[1] == gst.STATE_PLAYING
			 
	def play_pause(self):
		if self.isplaying():
			self.pause()
		else:
			self.play()
		
	def play(self):
		debug('play')
		self.player.set_state('playing')
		
	def pause(self):
		debug('pause')
		self.player.set_state('paused')
		
	def stop(self):
		debug('stop')
		self.player.set_state('null')
		
	def show_controls(self):
		debug('show controls')
		self.buttons.show()
		
	def hide_controls(self):
		self.buttons.hide()
		
	def toggle_controls(self):
		if self.buttons.get_property('visible'):
			self.buttons.hide()
		else:
			self.buttons.show()
		
	def fullscreen(self):
		self.win.fullscreen()
		self.hide_controls()
		
	def unfullscreen(self):
		self.win.unfullscreen()
		self.show_controls()
		
	def toggle_fullscreen(self):
		if self.win.__fullscreen:
			self.unfullscreen()
		else:
			self.fullscreen()
			
	def get_volume(self):
		return self.player.get_property('volume')
		
	def set_volume(self, level, absolute=True):
		if not absolute:
			level = max(0, min(1, self.get_volume() + level))
		self.player.set_property('volume', level)
		
	def get_position(self, percent=False):
		try:
			return max(0, self.player.query_position(gst.FORMAT_PERCENT if percent else gst.FORMAT_TIME, None)[0])
		except gst.QueryError:
			return 0
		
	def get_duration(self):
		try:
			return max(0, self.player.query_duration(gst.FORMAT_TIME, None)[0])
		except gst.QueryError:
			return 0
		
	def previous(self):
		debug('previous')
		pos = self.get_position()
		self.stop()
		if pos < 3 * gst.SECOND:
			try:
				self.load(self.playlist.previous())
			except StopIteration:
				pass
		self.play()
		
	def next(self):
		debug('next')
		self.stop()
		try:
			self.load(self.playlist.next())
		except StopIteration:
			pass
		self.play()
			
	def load(self, uri):
		debug('load', uri)
		i = self.lib.index(uri)
		tags = self.lib[i]._asdict()
		self.player.set_property('uri', uri)
		self.player.get_property('video_sink').set_xwindow_id(self.movie_window.window.xid)
		self.taginject.props.tags = 'replaygain-reference-level=%s,replaygain-track-gain=%s,replaygain-track-peak=%s' % (tags['reference_level'], tags['gain'], tags['peak'])
		
	def quit(self):
		self.player.set_state('null')
		gtk.main_quit()
		
	def update(self):
		try:
			self.buttons.set_position(self.get_position())
			self.buttons.set_duration(self.get_duration())
			self.buttons.slider.queue_draw()
			self.buttons.set_volume(self.get_volume())
		finally:
			return True
			
	def on_movie_window_clicked(self, window, event):
		if event.type == gtk.gdk.BUTTON_PRESS and event.button == 3:
			self.show_menu()
		elif event.type == gtk.gdk._2BUTTON_PRESS and event.button == 1:
			self.toggle_fullscreen()
		
	def on_about_to_finish(self, player):
		debug('about to finish')
		self.load(self.playlist.next())
		
	def on_window_state_event(self, window, event):
		if event.changed_mask & gtk.gdk.WINDOW_STATE_FULLSCREEN:
			self.win.__fullscreen = bool(event.new_window_state & gtk.gdk.WINDOW_STATE_FULLSCREEN)
		
	def on_expose_event(self, window, event, sink):
		sink.set_xwindow_id(window.window.xid)
		
	def on_state_changed(self, bus, message):
		old, new, pending = message.parse_state_changed()
		playing = (new == gst.STATE_PLAYING)
		self.buttons.widgets['play-pause'].set_stock_id(gtk.STOCK_MEDIA_PAUSE if playing else gtk.STOCK_MEDIA_PLAY)
		
	def on_tag(self, bus, message):
		for k in message.structure.keys():
			print k, '=', message.structure[k]
		
	def on_eos(self, bus, message):
		debug('eos')
		print threading.currentThread()
		self.next()
		
	def on_error(self, bus, message):
		self.stop()
		err, debug = message.parse_error()
		print "Error: %s" % err, debug
		
	def on_destroy(self, *args):
		self.quit()

if __name__=='__main__':
	import optparse
	
	parser = optparse.OptionParser(usage="%prog [songlist ...]", version="%prog 0:01")
	
	l = library.library(library.DEFAULT_PATH)
	p = []

	def my_callback(option, opt_str, value, parser):
		c = l.db.cursor()
		c.execute('select uri from media where %s=? order by artist,album,track_number' % opt_str[2:], (value,))
		for u in c:
			print u[0]
			p.append(u[0])

	parser.add_option('--album',
	callback=my_callback, action="callback", type="string",
	help="Include all songs in ALBUM in the playlist")
	parser.add_option('--artist',
	callback=my_callback, action="callback", type="string",
	help="Include all songs by ARTIST in the playlist")
	parser.add_option('--genre',
	callback=my_callback, action="callback", type="string",
	help="Include all songs in GENRE in the playlist")
	
	sys.argv = ['mcp-library'] + \
	['file:///home/ryan/Videos/Family Guy/%s' % f for f in os.listdir('/home/ryan/Videos/Family Guy')]

	options, args = parser.parse_args()

	for a in args:
		p.append(library.uri(a))

	Main(p)
	gtk.gdk.threads_init()
	gtk.main()
	print
