#!/usr/bin/env python
#
# Copyright (c) 2010, Ryan Marquardt
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are
# met:
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the project nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import pique.client
import optparse
import os
import readline
import sys
import shlex

parser = optparse.OptionParser()
parser.add_option('-c', dest='command', action='append', default=[],
  help='Command to run (may be used multiple times)')
parser.add_option('-i', dest='interactive', action='store_true',
  help='Enter interactive mode after running commands from -c string or file')

pique.client.add_default_options(parser)

parser.add_option('-v', '--verbose', dest='verbose', action='store_true',
  help='Display extra information')

options, args = pique.client.parse_args(parser)

if options.interactive and ('-' in args or not sys.stdin.isatty()):
	parser.error("Interactive mode requires standard input to be a terminal.")
if options.verbose:
	def debug(*args):
		print ' '.join(map(str,args))
else:
	def debug(*args):
		pass

class shell(object):
	def __init__(self, prompt, fd=sys.stdin, history_file=None):
		self.fd = fd
		self.prompt = prompt
		self.history_file = history_file
		
	def __enter__(self):
		if self.history_file:
			try:
				readline.read_history_file(self.history_file)
			except IOError:
				pass
		return self
	
	def __iter__(self):
		while True:
			yield raw_input(self.prompt)
	
	def __exit__(self, typ, val, tb):
		if self.history_file:
			readline.write_history_file(self.history_file)
		if self.fd.isatty():
			print

def printformat(obj):
	if obj is None:
		return
	elif isinstance(obj, (list,tuple,set)):
		print '\n'.join(map(repr,obj))
	elif isinstance(obj, basestring):
		print obj
	elif isinstance(obj, Exception):
		print '----- Remote Exception -----'
		print obj.args[0],
		print '----------------------------'
	else:
		print repr(obj)

debug('Connecting to host %s:%r' % (options.host, options.port))
serv = pique.client.Client()
serv.connect(options.host, options.port)

prompt = '(pique)%s: ' % options.host
history = os.path.expanduser('~/.config/pique/shell_history')

class CommandFile(object):
	def __init__(self, command):
		self.command = command
	def __enter__(self): return self
	def __exit__(self, typ, val, tb): pass
	def __iter__(self):
		yield self.command

sources = []
for cmd in options.command:
	debug('sys.argv has command', cmd)
	sources.append(CommandFile(cmd))
	
for a in args:
	debug('sys.argv has file', a)
	if a == '-':
		sources.append(sys.stdin)
	else:
		sources.append(open(a, 'r'))
		
if sys.stdin.isatty() and (not sources or (options.interactive and sys.stdin not in sources)):
	debug('Using interactive mode:', 'Interactive flag set.' if options.interactive else 'No other sources.')
	sources.append(shell(prompt, history_file=history))

if not sources:
	sources.append(sys.stdin)

for source in sources:
	with source:
		try:
			for line in source:
				argv = shlex.split(line, True)
				if argv:
					debug('Calling', *argv)
					handle, result = serv.call_quick(*argv)
					printformat(result)
		except (EOFError, KeyboardInterrupt):
			break

debug('Disconnecting')
